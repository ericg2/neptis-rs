use std::cmp::Ordering;
use std::hint::unreachable_unchecked;
use std::ops::{AddAssign, SubAssign};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

/*
 * Neptis
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */
use super::dtos::*;
use crate::apis::NeptisError;
use crate::rolling_secret::RollingSecret;
use crate::ui::file_size::FileSize;
use crate::ui::manager::ToShortIdString;
use base64::engine::Config;
use base64::{Engine as _, engine::general_purpose::STANDARD};
use chrono::{NaiveDateTime, Utc};
use reqwest::{Body, Client, IntoUrl, Method, Response};
use serde::de::DeserializeOwned;
use serde::{Deserialize, Deserializer, Serialize};
use tokio::sync::RwLock;

#[derive(Serialize, Deserialize, Clone)]
pub struct PointUsage {
    pub b_data_total: usize,
    pub b_data_used: usize,
    pub b_data_avail: usize,
    pub b_repo_total: usize,
    pub b_repo_used: usize,
    pub b_repo_avail: usize,
}

impl Default for PointUsage {
    fn default() -> Self {
        PointUsage {
            b_data_total: 0,
            b_data_used: 0,
            b_data_avail: 0,
            b_repo_total: 0,
            b_repo_used: 0,
            b_repo_avail: 0,
        }
    }
}

impl AddAssign for PointUsage {
    fn add_assign(&mut self, rhs: Self) {
        self.b_data_avail += rhs.b_data_avail;
        self.b_data_total += rhs.b_data_total;
        self.b_data_used += rhs.b_data_used;
        self.b_repo_avail += rhs.b_repo_avail;
        self.b_repo_total += rhs.b_repo_total;
        self.b_repo_used += rhs.b_repo_used;
    }
}

impl SubAssign for PointUsage {
    fn sub_assign(&mut self, rhs: Self) {
        self.b_data_avail -= rhs.b_data_avail;
        self.b_data_total -= rhs.b_data_total;
        self.b_data_used -= rhs.b_data_used;
        self.b_repo_avail -= rhs.b_repo_avail;
        self.b_repo_total -= rhs.b_repo_total;
        self.b_repo_used -= rhs.b_repo_used;
    }
}

#[derive(Serialize, Deserialize, Clone, Default)]

pub struct UserDto {
    pub user_name: String,
    pub first_name: String,
    pub last_name: String,
    pub create_date: NaiveDateTime,
    pub is_admin: bool,
    pub is_smb: bool,
    pub max_data_bytes: usize,
    pub max_repo_bytes: usize,
    pub free_data_bytes: usize,
    pub free_repo_bytes: usize,
    pub all_point_usage: PointUsage,
}

impl ToShortIdString for UserDto {
    fn to_short_id_string(&self) -> String {
        format!(
            "{} {} ({})",
            self.first_name.as_str(),
            self.last_name.as_str(),
            self.user_name.as_str()
        )
    }
}

#[derive(Serialize, Deserialize)]
pub struct UserForUpdateApi {
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub is_admin: Option<bool>,
    pub max_data_bytes: Option<i64>,
    pub max_snapshot_bytes: Option<i64>,
    pub password: Option<String>,
}

#[derive(Serialize, Deserialize)]
pub struct UserForLoginApi {
    pub user_name: String,
    pub password: String,
}

#[derive(Serialize, Deserialize, Clone, Default)]
pub struct UserForCreateApi {
    pub user_name: String,
    pub password: String,
    pub first_name: String,
    pub last_name: String,
    pub is_admin: bool,
    pub max_data_bytes: i64,
    pub max_snapshot_bytes: i64,
}

impl ToShortIdString for UserForCreateApi {
    fn to_short_id_string(&self) -> String {
        format!(
            "{} {} ({})",
            self.first_name.as_str(),
            self.last_name.as_str(),
            self.user_name.as_str()
        )
    }
}

pub type BasicAuth = (String, Option<String>);

#[derive(Debug, Clone)]
pub struct ApiKey {
    pub prefix: Option<String>,
    pub key: String,
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct CpuItem {
    pub timestamp: NaiveDateTime,
    pub name: String,
    pub percent: f32,
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct DiskItem {
    pub timestamp: NaiveDateTime,
    pub name: String,
    pub total_bytes: i64,
    pub avail_bytes: i64,
    pub file_system: String,
    pub mount_path: String,
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct NetworkItem {
    pub timestamp: NaiveDateTime,
    pub interface: String,
    pub rx_bytes: i64,
    pub tx_bytes: i64,
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct TempItem {
    pub timestamp: NaiveDateTime,
    pub name: String,
    pub temp_c: Option<f32>,
    pub peak_temp_c: Option<f32>,
    pub kill_temp_c: Option<f32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VGStatDto {
    pub vg_name: String,
    pub drive_total: u32,
    pub lv_total: u32,
    pub b_allocated: u64,
    pub b_free: u64,
    pub b_blk_size: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SystemSnapshotDto {
    pub api_version: String,
    pub cpus: Vec<CpuItem>,
    pub timestamp: NaiveDateTime,
    pub os_name: Option<String>,
    pub kernel_type: Option<String>,
    pub hostname: Option<String>,
    pub total_memory_bytes: i64,
    pub used_memory_bytes: i64,
    pub total_swap_bytes: i64,
    pub used_swap_bytes: i64,
    pub disks: Vec<DiskItem>,
    pub networks: Vec<NetworkItem>,
    pub temperatures: Vec<TempItem>,
    pub smb_connections: Option<usize>,
    pub smb_handles: Option<usize>,
    pub data_info: VGStatDto,
    pub repo_info: VGStatDto,
}

impl SystemSnapshotDto {
    pub fn print_info(self) {
        // Start with OS information.
        println!(
            "OS Name: {} (kernel: {})",
            self.os_name.unwrap_or("N/A".into()),
            self.kernel_type.unwrap_or("N/A".into())
        );
        println!(
            "Real Memory: {} / {} ({} free)",
            FileSize::prettify(self.used_memory_bytes as u64),
            FileSize::prettify(self.total_memory_bytes as u64),
            FileSize::prettify((self.total_memory_bytes - self.used_memory_bytes) as u64)
        );
        println!(
            "Swap Memory: {} / {} ({} free)",
            FileSize::prettify(self.used_swap_bytes as u64),
            FileSize::prettify(self.total_swap_bytes as u64),
            FileSize::prettify((self.total_swap_bytes - self.used_swap_bytes) as u64)
        );

        // Attempt to pull each CPU and their temperature.
        let process_cpu = |cpu: &CpuItem| {
            if let Some(core) = cpu.name.replace("cpu", "").trim().parse::<usize>().ok() {
                let fmt = vec![format!("core {}", core), format!("core{}", core)];
                format!(
                    "Core {} ({}%) ({})",
                    core,
                    cpu.percent,
                    self.temperatures
                        .iter()
                        .find(|x| fmt.contains(&x.name.trim().to_lowercase()))
                        .map(|x| format!(
                            "{}",
                            x.temp_c.map(|y| format!("{} C", y)).unwrap_or("N/A".into())
                        ))
                        .unwrap_or("N/A".into())
                )
            } else {
                format!("'{}' (N/A)", cpu.name)
            }
        };
        for chunk in self.cpus.chunks_exact(2) {
            match chunk {
                [a, b] => println!("{}  |  {}", process_cpu(a), process_cpu(b)),
                [a] => println!("{}", process_cpu(a)),
                _ => unreachable!(),
            }
        }

        println!(
            "\nDisk Information:\n{}",
            self.disks
                .into_iter()
                .map(|x| format!(
                    "{} on {} ({} / {})",
                    x.file_system,
                    x.mount_path,
                    FileSize::prettify((x.total_bytes - x.avail_bytes) as u64),
                    FileSize::prettify(x.total_bytes as u64)
                ))
                .collect::<Vec<_>>()
                .join("\n")
        );

        println!(
            "\nNetwork Information:\n{}",
            self.networks
                .into_iter()
                .map(|x| format!(
                    "{} ({} tx | {} rx)",
                    x.interface,
                    FileSize::prettify(x.tx_bytes as u64),
                    FileSize::prettify(x.rx_bytes as u64)
                ))
                .collect::<Vec<_>>()
                .join("\n")
        )
    }
}

#[derive(Serialize, Deserialize)]
pub struct AuthOutputDto {
    pub token: String,
    pub expire_date: NaiveDateTime,
}

pub struct WebApiConfig {
    pub base_url: String,
    pub client: Client,
    pub secret: Option<RollingSecret>,
    pub user_agent: Option<String>,
    pub auth: RwLock<Option<AuthOutputDto>>,
}

pub struct ApiBuilder<'a, U: IntoUrl> {
    config: &'a WebApiConfig,
    method: reqwest::Method,
    full_uri: U,
    body: Option<serde_json::Value>,
    queries: Vec<(String, String)>,
    token: Option<String>,
}

impl<'a, U: IntoUrl> ApiBuilder<'a, U> {
    pub fn new(
        config: &'a WebApiConfig,
        method: reqwest::Method,
        full_uri: U,
        token: Option<String>,
    ) -> Self {
        ApiBuilder::<'a, U> {
            config,
            method,
            full_uri,
            body: None,
            queries: vec![],
            token,
        }
    }

    pub fn with_body<T: Serialize>(mut self, body: T) -> Self {
        self.body = Some(serde_json::to_value(body).expect("Failed to serialize body"));
        self
    }

    pub fn with_opt_query<T: Serialize>(
        mut self,
        key: &str,
        val: Option<T>,
    ) -> Result<Self, NeptisError> {
        if let Some(v) = val {
            self.queries
                .push((key.to_string(), serde_json::to_string(&v)?));
        }
        Ok(self)
    }

    pub async fn get_success(&self) -> Result<(), NeptisError> {
        self.get_result_bytes().await.map(|_| ())
    }

    pub async fn get_result_bytes(&self) -> Result<Vec<u8>, NeptisError> {
        // First, we need to create the request.
        let do_full_req = || async {
            let mut final_url: String = self.full_uri.as_str().to_string();
            let mut final_body = self
                .body
                .as_ref()
                .map(|x| serde_json::to_vec(&x))
                .transpose()?;

            if let Some(ref secret) = self.config.secret {
                let mut full_query = final_url.replace(self.config.base_url.as_str(), "".into());
                full_query = full_query
                    .strip_prefix("/")
                    .unwrap_or(full_query.as_str())
                    .to_string();
                full_query = full_query
                    .strip_prefix("/api")
                    .unwrap_or(full_query.as_str())
                    .to_string();
                full_query = full_query
                    .strip_prefix("api/")
                    .unwrap_or(full_query.as_str())
                    .to_string();

                if !full_query.starts_with("/api/") {
                    full_query = "/api/".to_string() + full_query.as_str();
                }

                // Finally, encrypt the data into the "secure api"
                let enc_query = secret
                    .encrypt(full_query.as_bytes())
                    .map(|x| STANDARD.encode(x))
                    .ok_or(NeptisError::Str("Failed to encrypt query".into()))?;

                let mut enc_url = self.config.base_url.replace("/api", "");
                enc_url = enc_url
                    .strip_suffix("/")
                    .unwrap_or(enc_url.as_str())
                    .to_string();
                enc_url += format!("/secure/{}", enc_query).as_str();

                if let Some(body) = final_body {
                    // There is something in the body - we need to encrypt it as well.
                    final_body = Some(
                        secret
                            .encrypt(body.as_slice())
                            .map(|x| STANDARD.encode(x).as_bytes().to_vec())
                            .ok_or(NeptisError::Str("Failed to encrypt body!".into()))?,
                    );
                }
                final_url = enc_url
            }

            // Finally, build the request and process.
            let mut req_builder = self.config.client.request(self.method.clone(), final_url);

            for (k, v) in self.queries.iter() {
                req_builder = req_builder.query(&[(k.to_owned(), v.to_owned())]);
            }

            if let Some(ref user_agent) = self.config.user_agent {
                req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
            }

            if let Some(token) = self.token.clone() {
                req_builder = req_builder.bearer_auth(token);
            }

            if let Some(body) = final_body {
                req_builder = req_builder.body(body);
                req_builder = req_builder.header("Content-Type", "application/json");
            }

            let req = req_builder.build()?;
            let res = self.config.client.execute(req).await?.error_for_status()?;

            let mut res_body = res.bytes().await.ok().map(|x| x.to_vec());
            if let Some(r_body) = res_body {
                if r_body.is_empty() {
                    return Ok(vec![]);
                }
                if let Some(ref secret) = self.config.secret {
                    // We need to decode the body from base64.
                    let p_body = STANDARD
                        .decode(r_body.as_slice())
                        .map_err(|_| NeptisError::Str("Failed to decode!".into()))?;
                    res_body = Some(
                        secret
                            .decrypt(p_body.as_slice())
                            .ok_or(NeptisError::Str("Failed to decrypt body!".into()))?,
                    );
                } else {
                    res_body = Some(r_body);
                }
            }
            Ok(res_body.unwrap_or(vec![]))
        };

        // Attempt to do the request several times due to encryption.
        let mut ret = Err(NeptisError::Str("Failed to send request".into()));
        for _ in 0..2 {
            ret = do_full_req().await;
            if ret.is_ok() {
                break;
            }
        }
        ret
    }

    pub async fn get_result_str(&self) -> Result<String, NeptisError> {
        let ret = self.get_result_bytes().await?;
        if ret.len() == 0 {
            Ok(String::new())
        } else {
            Ok(String::from_utf8(ret)
                .ok()
                .ok_or(NeptisError::Str("Failed to convert output!".into()))?)
        }
    }

    pub async fn get_result_json<JsonOut: DeserializeOwned>(&self) -> Result<JsonOut, NeptisError> {
        let r_str = self.get_result_bytes().await?;
        Ok(serde_json::from_slice::<JsonOut>(r_str.as_slice())?)
    }
}

pub struct WebApi {
    config: WebApiConfig,
    user_name: String,
    password: String,
}

impl ToString for WebApi {
    fn to_string(&self) -> String {
        format!(
            "{} (Secure: {})",
            self.config.base_url.to_owned(),
            if self.config.secret.is_some() {
                "YES"
            } else {
                "NO"
            }
        )
    }
}

impl WebApi {
    pub fn get_username(&self) -> String {
        self.user_name.clone()
    }

    async fn ensure_auth(&self) -> Result<(), NeptisError> {
        let needs_refresh = {
            let r_auth = self.config.auth.read().await;
            match r_auth.as_ref() {
                Some(a) => Utc::now().naive_utc() > a.expire_date,
                None => !self.user_name.is_empty() && !self.password.is_empty(),
            }
        };

        if needs_refresh {
            let mut w_auth = self.config.auth.write().await;
            let still_needs_refresh = match w_auth.as_ref() {
                Some(a) => Utc::now().naive_utc() > a.expire_date,
                None => !self.user_name.is_empty() && !self.password.is_empty(),
            };

            if still_needs_refresh {
                let user_name = self.user_name.clone();
                let password = self.password.clone();

                let ret = self
                    .raw_post("/users/auth", None)
                    .with_body(UserForLoginApi {
                        user_name,
                        password,
                    })
                    .get_result_json::<AuthOutputDto>()
                    .await?;

                *w_auth = Some(ret);
            }
        }
        Ok(())
    }

    pub fn new(
        base_path: impl Into<String>,
        user_name: impl Into<String>,
        password: impl Into<String>,
        secret: Option<RollingSecret>,
    ) -> WebApi {
        WebApi {
            user_name: user_name.into(),
            password: password.into(),
            config: WebApiConfig {
                base_url: base_path.into(),
                client: Client::builder()
                    .timeout(Duration::from_secs(3))
                    .build()
                    .unwrap(),
                secret,
                user_agent: None,
                auth: RwLock::new(None),
            },
        }
    }

    async fn request(
        &self,
        method: reqwest::Method,
        rel_path: impl Into<String>,
    ) -> Result<ApiBuilder<'_, String>, NeptisError> {
        self.ensure_auth().await?;
        let token = {
            let r_auth = self.config.auth.read().await;
            r_auth.as_ref().map(|x| x.token.clone())
        };
        Ok(self.raw_request(method, rel_path, token))
    }

    fn raw_request(
        &self,
        method: reqwest::Method,
        rel_path: impl Into<String>,
        token: Option<String>,
    ) -> ApiBuilder<'_, String> {
        ApiBuilder::new(
            &self.config,
            method,
            format!("{}{}", self.config.base_url, rel_path.into()),
            token,
        )
    }

    async fn get(
        &self,
        rel_path: impl Into<String>,
    ) -> Result<ApiBuilder<'_, String>, NeptisError> {
        self.request(Method::GET, rel_path).await
    }

    async fn put(
        &self,
        rel_path: impl Into<String>,
    ) -> Result<ApiBuilder<'_, String>, NeptisError> {
        self.request(Method::PUT, rel_path).await
    }

    async fn post(
        &self,
        rel_path: impl Into<String>,
    ) -> Result<ApiBuilder<'_, String>, NeptisError> {
        self.request(Method::POST, rel_path).await
    }

    fn raw_post(
        &self,
        rel_path: impl Into<String>,
        token: Option<String>,
    ) -> ApiBuilder<'_, String> {
        self.raw_request(Method::POST, rel_path, token)
    }

    async fn delete(
        &self,
        rel_path: impl Into<String>,
    ) -> Result<ApiBuilder<'_, String>, NeptisError> {
        self.request(Method::DELETE, rel_path).await
    }

    // All requests will be implemented here!
    pub async fn get_all_mounts(&self) -> Result<Vec<MountDto>, NeptisError> {
        self.get("/mounts").await?.get_result_json().await
    }

    pub async fn put_one_mount(
        &self,
        name: &str,
        dto: PutForMountApi,
    ) -> Result<RepoJobDto, NeptisError> {
        self.put(format!("/mounts/id/{}", name))
            .await?
            .with_body(dto)
            .get_result_json()
            .await
    }

    pub async fn post_one_backup(&self, name: &str, lock: bool) -> Result<RepoJobDto, NeptisError> {
        self.post(format!("/mounts/id/{}/backup?lock={}", name, lock))
            .await?
            .get_result_json()
            .await
    }

    pub async fn post_one_check(&self, name: &str) -> Result<RepoJobDto, NeptisError> {
        self.post(format!("/mounts/id/{}/check", name))
            .await?
            .get_result_json()
            .await
    }

    pub async fn post_one_restore(
        &self,
        name: &str,
        snapshot: &str,
        delete: bool,
    ) -> Result<RepoJobDto, NeptisError> {
        self.post(format!(
            "/mounts/id/{}/snapshots/{}/restore?delete={}",
            name, snapshot, delete
        ))
        .await?
        .get_result_json()
        .await
    }

    pub async fn lock_one_snapshot(&self, name: &str, snapshot: &str) -> Result<(), NeptisError> {
        self.post(format!("/mounts/id/{}/snapshots/{}/lock", name, snapshot))
            .await?
            .get_success()
            .await
    }

    pub async fn unlock_one_snapshot(&self, name: &str, snapshot: &str) -> Result<(), NeptisError> {
        self.delete(format!("/mounts/id/{}/snapshots/{}/lock", name, snapshot))
            .await?
            .get_success()
            .await
    }

    pub async fn get_one_snapshot(
        &self,
        name: &str,
        snapshot: &str,
    ) -> Result<SnapshotFileDto, NeptisError> {
        self.get(format!("/mounts/id/{}/snapshots/{}", name, snapshot))
            .await?
            .get_result_json()
            .await
    }

    pub async fn delete_one_snapshot(&self, name: &str, snapshot: &str) -> Result<(), NeptisError> {
        self.delete(format!("/mounts/id/{}/snapshots/{}", name, snapshot))
            .await?
            .get_success()
            .await
    }

    pub async fn get_all_snapshots(&self, name: &str) -> Result<Vec<SnapshotFileDto>, NeptisError> {
        self.get(format!("/mounts/id/{}/snapshots", name))
            .await?
            .get_result_json()
            .await
    }

    pub async fn get_all_jobs(
        &self,
        n: usize,
        o: Option<usize>,
    ) -> Result<Vec<RepoJobDto>, NeptisError> {
        self.get(format!("/mounts/jobs?n={}&o={}", n, o.unwrap_or(0)))
            .await?
            .get_result_json()
            .await
    }

    pub async fn get_all_jobs_for_mount(&self, name: &str) -> Result<Vec<RepoJobDto>, NeptisError> {
        self.get(format!("/mounts/id/{}/jobs", name))
            .await?
            .get_result_json()
            .await
    }

    pub async fn get_all_auto_jobs_for_mount(
        &self,
        name: &str,
    ) -> Result<Vec<AutoJobDto>, NeptisError> {
        self.get(format!("/mounts/id/{}/autojobs", name))
            .await?
            .get_result_json()
            .await
    }

    pub async fn put_one_auto_job_for_mount(
        &self,
        name: &str,
        dto: PutForAutoJobWebApi,
    ) -> Result<AutoJobDto, NeptisError> {
        self.put(format!("/mounts/id/{}/autojobs", name))
            .await?
            .with_body(dto)
            .get_result_json()
            .await
    }

    pub async fn delete_one_auto_job_for_mount(
        &self,
        name: &str,
        a_name: &str,
    ) -> Result<(), NeptisError> {
        self.delete(format!("/mounts/id/{}/autojobs", name))
            .await?
            .with_body(a_name.to_string())
            .get_success()
            .await
    }

    pub async fn delete_one_mount(&self, name: &str) -> Result<RepoJobDto, NeptisError> {
        self.delete(format!("/mounts/id/{}", name))
            .await?
            .get_result_json()
            .await
    }

    pub async fn browse_file(&self, path: &str) -> Result<Vec<NodeDto>, NeptisError> {
        self.post("/mounts/browse")
            .await?
            .with_body(path.to_string())
            .get_result_json()
            .await
    }

    pub async fn dump_file(
        &self,
        path: &str,
        o: Option<u64>,
        n: Option<usize>,
    ) -> Result<String, NeptisError> {
        self.get(format!(
            "/mounts/dump?o={}&n={}",
            o.unwrap_or(0),
            n.unwrap_or(usize::MAX)
        ))
        .await?
        .with_body(path.to_string())
        .get_result_str()
        .await
    }

    pub async fn put_file(&self, dto: PutForFileApi) -> Result<(), NeptisError> {
        self.put("/mounts/file")
            .await?
            .with_body(dto)
            .get_success()
            .await
    }

    pub async fn post_file(&self, dto: PostForFileApi) -> Result<(), NeptisError> {
        self.post("/mounts/file")
            .await?
            .with_body(dto)
            .get_success()
            .await
    }

    pub async fn delete_file(&self, path: &str) -> Result<(), NeptisError> {
        self.delete("/mounts/file")
            .await?
            .with_body(path)
            .get_success()
            .await
    }

    pub async fn get_info(&self) -> Result<SystemSnapshotDto, NeptisError> {
        self.get("/sys/info").await?.get_result_json().await
    }

    pub async fn shutdown(&self) -> Result<(), NeptisError> {
        self.post("/sys/shutdown").await?.get_success().await
    }

    pub async fn restart(&self) -> Result<(), NeptisError> {
        self.post("/sys/restart").await?.get_success().await
    }

    pub async fn can_kill_safe(&self) -> Result<bool, NeptisError> {
        self.get("/sys/safe").await?.get_result_json().await
    }

    pub async fn enable_smb(&self, pass: &str) -> Result<(), NeptisError> {
        self.put("/users/smb")
            .await?
            .with_body(pass)
            .get_success()
            .await
    }

    pub async fn disable_smb(&self) -> Result<(), NeptisError> {
        self.delete("/users/smb").await?.get_success().await
    }

    pub async fn get_all_users(&self) -> Result<Vec<UserDto>, NeptisError> {
        self.get("/users").await?.get_result_json().await
    }

    pub async fn get_one_user(&self, name: &str) -> Result<UserDto, NeptisError> {
        self.get(format!("/users/id/{}", name))
            .await?
            .get_result_json()
            .await
    }

    pub async fn delete_one_user(&self, name: &str) -> Result<(), NeptisError> {
        self.delete(format!("/users/id/{}", name))
            .await?
            .get_success()
            .await
    }

    pub async fn put_password(&self, pass: &str) -> Result<(), NeptisError> {
        self.put("/users/pass")
            .await?
            .with_body(pass.to_string())
            .get_success()
            .await
    }

    pub async fn put_one_user(
        &self,
        name: &str,
        dto: UserForUpdateApi,
    ) -> Result<UserDto, NeptisError> {
        self.put(format!("/users/id/{}", name))
            .await?
            .with_body(dto)
            .get_result_json()
            .await
    }

    pub async fn create_one_user(&self, dto: UserForCreateApi) -> Result<UserDto, NeptisError> {
        self.post("/users")
            .await?
            .with_body(dto)
            .get_result_json()
            .await
    }

    pub async fn get_all_subscriptions(&self) -> Result<Vec<SubscriptionDto>, NeptisError> {
        self.get("/subscriptions").await?.get_result_json().await
    }

    pub async fn get_one_subscription(&self, sid: &str) -> Result<SubscriptionDto, NeptisError> {
        self.get(format!("/subscriptions/{sid}"))
            .await?
            .get_result_json()
            .await
    }

    pub async fn put_one_subscription(
        &self,
        sid: &str,
        dto: PutForSubscriptionApi,
    ) -> Result<SubscriptionDto, NeptisError> {
        self.put(format!("/subscriptions/{sid}"))
            .await?
            .with_body(dto)
            .get_result_json()
            .await
    }

    pub async fn post_one_subscription(
        &self,
        dto: PostForSubscriptionApi,
    ) -> Result<(), NeptisError> {
        self.post("/subscriptions")
            .await?
            .with_body(dto)
            .get_success()
            .await
    }

    pub async fn delete_one_subscription(&self, sid: &str) -> Result<(), NeptisError> {
        self.delete(format!("/subscriptions/{sid}"))
            .await?
            .get_success()
            .await
    }

    pub async fn get_all_messages(&self, new_only: bool) -> Result<Vec<Message>, NeptisError> {
        self.get(format!("/messages?new={new_only}"))
            .await?
            .get_result_json()
            .await
    }

    pub async fn get_one_message(&self, sid: &str) -> Result<Message, NeptisError> {
        self.get(format!("/messages/{sid}"))
            .await?
            .get_result_json()
            .await
    }

    pub async fn send_one_message(&self, dto: PostForMessageApi) -> Result<(), NeptisError> {
        self.post("/messages")
            .await?
            .with_body(dto)
            .get_success()
            .await
    }
}

impl Default for WebApiConfig {
    fn default() -> Self {
        WebApiConfig {
            base_url: "http://localhost".to_owned(),
            user_agent: Some("OpenAPI-Generator/v1/rust".to_owned()),
            client: Client::new(),
            secret: None,
            auth: RwLock::new(None),
        }
    }
}
