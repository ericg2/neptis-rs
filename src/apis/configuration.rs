/*
 * Neptis
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */
use crate::apis::config_api::UpdateGlobalConfigError;
use crate::apis::notification_api::GetAllNotificationConfigsError;
use crate::apis::{Error, ResponseContent};
use crate::rolling_secret::RollingSecret;
use base64::engine::Config;
use base64::{Engine as _, engine::general_purpose::STANDARD};
use reqwest::{Body, Client, IntoUrl, Response};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone)]
pub struct Configuration {
    pub base_path: String,
    pub user_agent: Option<String>,
    pub client: Client,
    pub secret: Option<RollingSecret>,
    pub basic_auth: Option<BasicAuth>,
    pub oauth_access_token: Option<String>,
    pub bearer_access_token: Option<String>,
    pub api_key: Option<ApiKey>,
}

pub type BasicAuth = (String, Option<String>);

#[derive(Debug, Clone)]
pub struct ApiKey {
    pub prefix: Option<String>,
    pub key: String,
}

impl Configuration {
    pub fn new() -> Configuration {
        Configuration::default()
    }

    pub async fn execute<
        'a,
        JsonIn: Serialize,
        U: IntoUrl,
        E: Deserialize<'a>,
        JsonOut: Deserialize<'a>,
    >(
        &self,
        method: reqwest::Method,
        full_uri: &U,
        body: Option<JsonIn>,
    ) -> Result<Option<JsonOut>, Error<E>> {
        // First, we need to create the request.
        let mut final_url = full_uri.as_str();
        let mut final_body = body.map(|x| serde_json::to_vec(&x)).transpose()?;

        if let Some(ref secret) = self.secret {
            let mut full_query = final_url.replace(self.base_path.as_str(), "".into());
            full_query = full_query
                .strip_prefix("/")
                .unwrap_or(full_query.as_str())
                .to_string();
            if !full_query.starts_with("/api/") {
                full_query = "/api/".to_string() + full_query.as_str();
            }

            // Finally, encrypt the data into the "secure api"
            let enc_query = secret
                .encrypt(full_query.as_bytes())
                .map(|x| STANDARD.encode(x))
                .ok_or("Failed to encrypt query".into())?;

            let mut enc_url = self.base_path.replace("/api", "");
            enc_url = enc_url
                .strip_suffix("/")
                .unwrap_or(enc_url.as_str())
                .to_string();
            enc_url += format!("/secure/{}", enc_query).as_str();

            if let Some(body) = final_body {
                // There is something in the body - we need to encrypt it as well.
                final_body = Some(
                    secret
                        .encrypt(&body[..])
                        .ok_or("Failed to encrypt body!".into())?,
                );
            }
        }

        // Finally, build the request and process.
        let mut req_builder = self.client.request(method, final_url);
        if let Some(ref user_agent) = self.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = self.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        if let Some(body) = final_body {
            req_builder = req_builder.body(body);
        }

        let req = req_builder.build()?;
        let res = self.client.execute(req).await?;
        let mut res_body = res
            .bytes()
            .await
            .ok()
            .map(|x| x.to_vec())
            .ok_or(Error::from)?;
        if let Some(ref secret) = self.secret {
            res_body = secret
                .decrypt(&res_body[..])
                .ok_or("Failed to decrypt body!".into())?;
        }

        let status = res.status();
        if !status.is_client_error() && !status.is_server_error() {
            // We need to convert the output to JSON and return.
            let json_res = serde_json::from_slice(&res_body[..])?;
            Ok(json_res)
        } else {
            let entity: Option<E> = serde_json::from_slice(&res_body.as_slice()).ok();
            Err(Error::ResponseError(ResponseContent {
                status,
                content,
                entity,
            }))
        }
    }
}

impl Default for Configuration {
    fn default() -> Self {
        Configuration {
            base_path: "http://localhost".to_owned(),
            user_agent: Some("OpenAPI-Generator/v1/rust".to_owned()),
            client: Client::new(),
            basic_auth: None,
            oauth_access_token: None,
            bearer_access_token: None,
            api_key: None,
        }
    }
}
